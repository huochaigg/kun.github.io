
```
模板 Template (SFC/HTML)
       ↓ 编译器编译
AST（抽象语法树）
       ↓ 转换
Render Function（JS函数）
       ↓ 执行
VNode（虚拟 DOM）
       ↓ patch（diff 比较）
真实 DOM
```

## 我的疑问：

### .VNode → patch（对比阶段），每次更新都会额外存一份VNode吗？以供下次对比？

是的，Vue 在内存中保留“上一轮的 VNode 树”作为旧节点进行 diff 比较，并且 旧 VNode 在 diff 完之后会被 GC 回收，每个组件实例只维护一棵自己的 subTree（VNode 树）

### 那么template为什么不直接转为虚拟 DOM 树呢？而是先转为AST再转为渲染函数再转为VNode树？

#### DeepSeek:

#### 设计方面：

这种分层设计体现了Vue的架构理念：

- **关注点分离**：编译时和运行时逻辑分离
- **可扩展性**：便于添加自定义编译器或自定义渲染器
- **渐进式**：支持template和JSX等多种写法

#### AST（抽象语法树）的必要性：

**AST作为中间表示层**提供了关键优势：
- **结构化分析**：AST是对模板的完整结构化表示，便于进行静态分析和优化
- **跨平台兼容**：AST是平台无关的，可以基于它生成不同平台的渲染代码
- **转换灵活性**：在AST阶段可以进行各种转换和优化（如静态节点提升）

#### 2. 渲染函数的作用

将AST转换为渲染函数而不是直接生成VNode，主要因为：

- **动态性**：渲染函数可以在每次组件更新时被调用，根据最新状态生成VNode
- **优化空间**：Vue可以在编译时对渲染函数进行优化（如静态节点提升）
- **灵活性**：开发者也可以直接编写渲染函数，绕过template编译过程

#### 3. 性能考量

虽然看起来多了一步转换，但实际上：

- **编译时优化**：AST到渲染函数的转换是在构建时完成的（使用vue-loader等工具）
- **运行时效率**：预编译的渲染函数比直接解析template到VNode更高效


Vue渲染相关：
https://zhuanlan.zhihu.com/p/609128099