
## HTTP 和 HTTPS 区别

|对比项|HTTP|HTTPS|
|---|---|---|
|**是否加密**|❌ 明文传输，容易被窃听|✅ 使用 SSL/TLS 加密，安全性高|
|**端口号**|默认端口 80|默认端口 443|
|**URL 格式**|`http://` 开头|`https://` 开头|
|**安全性**|无加密，容易被中间人攻击（抓包、篡改）|加密+认证+完整性校验|
|**性能**|快（无加密开销）|慢一点（但现代优化已趋近）|
|**证书**|不需要|需要服务器配置 SSL 证书|
|**SEO 影响**|差，搜索引擎会提示不安全|更有利于排名和信任|

## 浏览器请求生命周期

```
1. 浏览器启动
2. 输入 URL，开始加载页面
3. DNS 解析、TCP/TLS 连接建立
4. 发送 HTTP 请求，获取响应
5. HTML 解析，构建 DOM 树
6. 加载 CSS、JS、图片等资源，构建 CSSOM
7. 构建 Render Tree，开始渲染
8. 页面首次绘制 (First Paint)
9. 页面可交互 (DOMContentLoaded、load)
10. 用户交互
11. 页面卸载（关闭、跳转、刷新）
```

## 什么是 CORS？如何实现？

**CORS（跨域资源共享，Cross-Origin Resource Sharing）** 是一种浏览器的安全策略，它允许浏览器向**不同源的服务器发起请求**时，服务器通过设置响应头来授权访问。

跨域：浏览器认为其中任一不同就算跨域（**协议、域名、端口**），

CORS 是一种机制，它允许服务端告诉浏览器：

“我这个资源可以被某个特定的外域访问”
靠设置**响应头**来实现。

服务端设置

```
Access-Control-Allow-Origin: https://abc.com

Access-Control-Allow-Origin: * // 不建议
```

就允许来自 `https://abc.com` 的 JS 访问这个资源。

完整的 CORS 响应头（服务端）：

```
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: Content-Type, Authorization
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 600
```

## HTTP 状态码 301、302、307、308 有什么区别？

| 状态码     | 是否永久 | 请求方法改变？            | 特点说明                         |
| ------- | ---- | ------------------ | ---------------------------- |
| **301** | ✅ 永久 | ✅ 可能改变（POST → GET） | 浏览器/搜索引擎会记住跳转（缓存）            |
| **302** | ❌ 临时 | ✅ 可能改变（POST → GET） | 原始意义是临时，但多数浏览器也改变方法          |
| **307** | ❌ 临时 | ❌ 不改变（保持 POST）     | 明确要求**方法不变**，适用于需要安全重试的 POST |
| **308** | ✅ 永久 | ❌ 不改变（保持 POST）     | 和 301 类似，但不允许改变方法            |

## GET 和 POST 的区别？

### 基本语义
|方法|含义|用途示例|
|---|---|---|
|GET|**获取资源**（查）|查询文章、获取用户信息等|
|POST|**提交资源/处理请求**（增）|提交表单、新建用户、上传数据|
### 区别

| 对比项                   | GET                         | POST                                |
| --------------------- | --------------------------- | ----------------------------------- |
| **请求参数位置**            | 放在 URL 中：`/api/user?id=123` | 放在请求体中（body）：`{id:123}`             |
| **可见性**               | 参数明文显示在地址栏，**不安全**          | 参数藏在请求体中，相对更安全                      |
| **浏览器缓存**             | 会被浏览器缓存                     | 不会被缓存                               |
| **书签收藏**              | 可以直接收藏                      | 不可以                                 |
| **幂等性**（重要）           | 是，刷新多次不会造成影响                | 否，刷新可能会导致数据重复创建等问题                  |
| **长度限制**              | URL 长度有限（一般 ≤ 2KB）          | 无明显限制，可上传大量数据（如文件）                  |
| **默认 `Content-Type`** | `text/plain` 或无             | `application/x-www-form-urlencoded` |
| **语义强调**              | 获取资源，不应修改服务端数据              | 提交数据，可能引起服务端状态变化                    |

## 什么是强缓存和协商缓存？怎么判断命中？

| 缓存方式        | 控制字段（响应头）                      | 特点                        |
| ----------- | ------------------------------ | ------------------------- |
| 强缓存（强制使用缓存） | `Cache-Control`, `Expires`     | **不会向服务器发送请求，直接使用本地缓存**   |
| 协商缓存（条件请求）  | `ETag` / `Last-Modified` + 请求头 | 向服务器发请求，服务器决定是否返回新内容或 304 |
…… 待补充
## 什么是幂等性？哪些方法是幂等的？

多次执行对服务端的结果没有副作用，一般使用GET请求获取数据，多次请求对服务端，数据库，日志等没有什么影响，所以是幂等的。而POST请求会提交表单，改变服务端状态，更新数据库内容，所以是不幂等的。

## HTTP2 的多路复用是如何实现的？

多路复用：所有请求和响应都通过一个 TCP 连接进行复用，彼此不阻塞......待补充

## 什么情况下返回 204 状态码？它和 200 有什么区别？


- 状态码：204
- 无返回体（`response body` 为空）
- 有响应头，但没有内容
- 通常用于「只需告知成功、但无需数据返回」的场景

| 状态码              | 含义          | 有返回体？                | 常见用途                             |
| ---------------- | ----------- | -------------------- | -------------------------------- |
| `200 OK`         | 请求成功        | 有（可以是 JSON、HTML、文本等） | 普通成功响应，带有内容                      |
| `204 No Content` | 请求成功，但无内容返回 |  无                   | 表单提交成功但无反馈、按钮点击后无需刷新、AJAX 无刷新交互等 |

204比200更轻量的”成功“响应


## HTTPS 握手过程

### 整体流程：

浏览器访问 HTTPS 网站时：

1. 客户端发起连接请求
    
2. 服务端返回证书（含公钥）
    
3. 客户端验证证书是否合法
    
4. 客户端生成「对称密钥」并用服务端公钥加密后发出
    
5. 服务端用私钥解密拿到「对称密钥」
    
6. **双方使用对称密钥开始加密通信**

### TCP三次握手

- **第一次握手**：客户端发送一个带 SYN 标志的包，表示 “我要连接你”；
    
- **第二次握手**：服务器收到后，回复一个 **SYN + ACK**，表示 “我收到了，同时我也准备好了”；
    
- **第三次握手**：客户端再回复一个 ACK，表示 “我知道你准备好了”；
### 四次挥手（断开连接）

- **第一次挥手**：客户端发送 FIN，请求断开连接（我要关闭发送）；
    
- **第二次挥手**：服务器返回 ACK（我知道了，但我还有数据要传）；
    
- **第三次挥手**：服务器准备好后，也发送一个 FIN（我现在也关闭了）；
    
- **第四次挥手**：客户端返回 ACK（确认断开）；

- 之后客户端会进入一个 **TIME_WAIT** 状态，等一会儿再彻底关闭，以确保服务器收到了最后的 ACK。

### ## 为什么不是两次握手/两次挥手？

- 握手需要确保双向通信都准备好，所以要三次。
    
- 挥手中，一方可能还有剩余数据未发送完，所以需要等它主动 FIN，因此是四次。

|标志位|含义|用于哪种场景|
|---|---|---|
|**SYN**|Synchronize|建立连接（握手）|
|**ACK**|Acknowledgment|确认收到（应答）|
|**FIN**|Finish|断开连接（挥手）|

### TCP连接建立以后，下次请求是不是复用？

默认情况下，**每次 HTTP 请求都会重新建立 TCP 连接（开销大）**。

但现代浏览器里有两个优化方式可以 **复用连接**：

#### 1. HTTP/1.1 的 `Connection: keep-alive`

- 保持 TCP 连接不关闭，多个请求复用同一连接；
    
- 默认开启（除非明确设置 `Connection: close`）；
    
- 有个**空闲超时**（通常几十秒）后会自动断开。
    

####  2. HTTP/2/3 支持**多路复用**

- 一条连接中可以并发多个请求，不必等待前一个完成；
    
- 更快更省资源，是现代主流。

## SSL/TLS握手

- **SSL（Secure Sockets Layer）** 和 **TLS（Transport Layer Security）** 是一种加密协议；
    
- 目的是让 **客户端（浏览器）和服务器** 之间的通信是安全的；
    
- TLS 是 SSL 的升级版（现代使用的其实是 TLS）。

HTTPS 在开始正式通信前，会走一个 **TLS 握手流程**，大致步骤如下：

1. ### 客户端发起请求
    - 浏览器发出请求：告诉服务器「我支持哪些加密方式」。
2. ### 服务器响应
    - 服务器返回：**SSL 证书**、选择的加密方式等。
3. ### 客户端验证证书
    - 验证证书是否可信（是否是受信 CA 签发、是否过期等）。
    - 如果信任，则生成一个随机的对称密钥（**用于后续加密通信**）。
4. ### 客户端使用公钥加密密钥
    - 把这个对称密钥，用服务器的 **公钥加密** 传过去。
5. ### 服务器使用私钥解密
    - 拿到密钥后，客户端和服务器用它进行 **对称加密通信**。


## 证书的作用

SSL 证书是服务器用来「证明自己身份 + 提供公钥」的数字文档，作用如下：

| 作用          | 描述                          |
| ----------- | --------------------------- |
| **身份认证**    | 浏览器可通过证书判断服务器是否是真实可信（非冒牌网站） |
| **传输加密**    | 提供服务器公钥用于数据加密，保护传输安全        |
| **防止中间人攻击** | 验证服务器合法性，防止被劫持或篡改           |
| **包含信息**    | 域名、颁发机构（CA）、公钥、有效期、签名等      |

## HTTP1/2/3有哪些区别

HTTP/2 多路复用，头部压缩

HTTP/3 弃用 TCP，改用 UDP + QUIC，结合了 TCP 的可靠性 + UDP 的高性能，解决了 HTTP/2 的核心瓶颈。

## HTTP请求方法和语义

| 方法        | 语义（用途）                 | 是否幂等 | 是否常用于 REST |
| --------- | ---------------------- | ---- | ---------- |
| `GET`     | **获取资源**，只读取，不修改资源     | ✅ 是  | ✅ 是        |
| `POST`    | **提交数据**（创建资源、触发操作）    | ❌ 否  | ✅ 是        |
| `PUT`     | **更新整个资源**（用新数据替换旧数据）  | ✅ 是  | ✅ 是        |
| `PATCH`   | **局部更新资源**（只改部分字段）     | ❌ 否  | ✅ 是        |
| `DELETE`  | **删除资源**               | ✅ 是  | ✅ 是        |
| `HEAD`    | 获取资源**响应头**，不返回 body   | ✅ 是  | ❌ 较少用      |
| `OPTIONS` | **探测服务器支持哪些方法/跨域权限检查** | ✅ 是  | ⚠️ 特殊用途    |
### `OPTIONS` 方法详解

- `OPTIONS` 方法用于：**探测目标资源支持哪些请求方法和功能**；
    
- 它不会返回实际的数据，只会返回响应头中的「允许行为」；
    
- 它也是 **CORS 跨域机制中的预检请求（preflight request）**；

#### 为什么用 `GET` 请求却看到浏览器发了 `OPTIONS` 请求？

这是因为你的请求**触发了 CORS 的“预检请求”机制**（preflight）。虽然是 `GET`，但只要**满足“非简单请求”的条件**，浏览器就会自动先发送一个 `OPTIONS` 请求来问后端：“我能发这个请求吗？“

|条件|是否触发 OPTIONS|
|---|---|
|`Content-Type` 是 `application/json`|✅ 会触发|
|设置了 `withCredentials: true`（带 cookie）|✅ 会触发|
|自定义请求头（如 `Authorization`）|✅ 会触发|
|方法是 `PUT`, `PATCH`, `DELETE`|✅ 会触发|
|`GET` 或 `POST` 且不带上面这些情况|❌ 不触发（为“简单请求”）|
#### 什么是简单请求 / 非简单请求

### 简单请求的条件（**只满足这三点才是简单请求**）：

1. 方法是以下三种之一：
    - `GET`
    - `POST`
    - `HEAD`
2. 请求头必须只包含：
    - `Accept`
    - `Accept-Language`
    - `Content-Language`
    - `Content-Type`（且仅限这三种：`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`）
3. 不能使用 `withCredentials`，不能携带自定义头部（如 `Authorization`）。

### 非简单请求（也称 “需预检请求”）：

任何 **不满足上面任一条件** 的请求，浏览器都会：

- **自动先发一个 `OPTIONS` 请求**（预检）；
- 服务端返回通过后，浏览器才会继续发送真正的请求。