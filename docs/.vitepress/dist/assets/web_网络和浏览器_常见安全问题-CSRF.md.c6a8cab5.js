import{_ as e,c as a,o as t,Q as s}from"./chunks/framework.ef145a76.js";const y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"web/网络和浏览器/常见安全问题-CSRF.md","filePath":"web/网络和浏览器/常见安全问题-CSRF.md"}'),n={name:"web/网络和浏览器/常见安全问题-CSRF.md"},o=s(`<p>CSRF（跨站请求伪造）</p><ul><li><p>攻击者诱导用户在<strong>登录状态</strong>下访问恶意页面</p></li><li><p>利用浏览器**自动携带身份凭证（如 Cookie）**的特性</p></li><li><p>向受信任网站发起请求，并伪装成用户</p></li></ul><h2 id="原理" tabindex="-1">原理： <a class="header-anchor" href="#原理" aria-label="Permalink to &quot;原理：&quot;">​</a></h2><p>攻击者诱导用户点击一个链接、按钮、下载文件或触发下载动作，这会导致用户浏览器向目标网站发起请求，并带上身份 Cookie，从而完成敏感操作。</p><p>例子一：链接诱导下载触发操作</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&lt;a href=&quot;https://bank.com/export?delete=true&quot; download=&quot;abc.csv&quot;&gt;点击下载报表&lt;/a&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">&lt;a href=&quot;https://bank.com/export?delete=true&quot; download=&quot;abc.csv&quot;&gt;点击下载报表&lt;/a&gt;</span></span></code></pre></div><ul><li><p>用户以为是下载报表，其实是 GET 请求带有危险参数：?delete=true</p></li><li><p>服务器如果误把这当作合法操作，比如“导出并删除数据”，用户数据就被删除了</p></li></ul><p>例子二：构造 blob 下载诱导 POST</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&lt;form id=&quot;hack&quot; action=&quot;https://bank.com/deleteAllData&quot; method=&quot;POST&quot; style=&quot;display:none&quot;&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">  &lt;input type=&quot;hidden&quot; name=&quot;confirm&quot; value=&quot;yes&quot;&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;/form&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;a href=&quot;javascript:document.getElementById(&#39;hack&#39;).submit()&quot;&gt;点击下载文件&lt;/a&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">&lt;form id=&quot;hack&quot; action=&quot;https://bank.com/deleteAllData&quot; method=&quot;POST&quot; style=&quot;display:none&quot;&gt;</span></span>
<span class="line"><span style="color:#24292e;">  &lt;input type=&quot;hidden&quot; name=&quot;confirm&quot; value=&quot;yes&quot;&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;/form&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;a href=&quot;javascript:document.getElementById(&#39;hack&#39;).submit()&quot;&gt;点击下载文件&lt;/a&gt;</span></span></code></pre></div><ul><li>用户以为是下载操作，点了以后实际是偷偷发起了删除请求</li></ul><p>例子三：通过恶意 zip / exe 等触发特殊行为</p><ul><li><p>用户下载了一个 zip 文件</p></li><li><p>文件名链接中带了副作用参数（某些系统会自动解析）</p></li><li><p>少数老旧浏览器或服务会错误执行这些“点击下载”背后的请求</p></li></ul><h2 id="防御方法" tabindex="-1">防御方法： <a class="header-anchor" href="#防御方法" aria-label="Permalink to &quot;防御方法：&quot;">​</a></h2><h3 id="csrf-token" tabindex="-1">CSRF token <a class="header-anchor" href="#csrf-token" aria-label="Permalink to &quot;CSRF token&quot;">​</a></h3><ul><li><p>服务器给每个用户生成一个 <strong>一次性 token</strong></p></li><li><p>这个 token 不放在 Cookie 里，而是通过页面注入或接口返回给前端</p></li><li><p>前端每次提交请求时必须显式带上这个 token（如放在 header 或 body 中）</p></li><li><p>后端检查 token 是否正确，防止伪造请求</p></li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">// 假设从 HTML 中获取的 token</span></span>
<span class="line"><span style="color:#e1e4e8;">const token = document.querySelector(&#39;meta[name=&quot;csrf-token&quot;]&#39;).content</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">fetch(&quot;/transfer&quot;, {</span></span>
<span class="line"><span style="color:#e1e4e8;">  method: &quot;POST&quot;,</span></span>
<span class="line"><span style="color:#e1e4e8;">  headers: {</span></span>
<span class="line"><span style="color:#e1e4e8;">    &quot;Content-Type&quot;: &quot;application/json&quot;,</span></span>
<span class="line"><span style="color:#e1e4e8;">    &quot;X-CSRF-Token&quot;: token</span></span>
<span class="line"><span style="color:#e1e4e8;">  },</span></span>
<span class="line"><span style="color:#e1e4e8;">  body: JSON.stringify({ to: &quot;hacker&quot;, amount: 1000 })</span></span>
<span class="line"><span style="color:#e1e4e8;">})</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">// 假设从 HTML 中获取的 token</span></span>
<span class="line"><span style="color:#24292e;">const token = document.querySelector(&#39;meta[name=&quot;csrf-token&quot;]&#39;).content</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">fetch(&quot;/transfer&quot;, {</span></span>
<span class="line"><span style="color:#24292e;">  method: &quot;POST&quot;,</span></span>
<span class="line"><span style="color:#24292e;">  headers: {</span></span>
<span class="line"><span style="color:#24292e;">    &quot;Content-Type&quot;: &quot;application/json&quot;,</span></span>
<span class="line"><span style="color:#24292e;">    &quot;X-CSRF-Token&quot;: token</span></span>
<span class="line"><span style="color:#24292e;">  },</span></span>
<span class="line"><span style="color:#24292e;">  body: JSON.stringify({ to: &quot;hacker&quot;, amount: 1000 })</span></span>
<span class="line"><span style="color:#24292e;">})</span></span></code></pre></div><p>这样攻击者拿不到token，（不同源、token 不在 cookie， 没法访问页面的 DOM）</p><p>注意：CSRF token前端不要存储在cookie或者localStorage中，可以存储在状态管理中，每次刷新重新请求数据拿CSRF token</p><p>或者服务端注入meta标签中</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">&lt;head&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">  &lt;meta name=&quot;csrf-token&quot; content=&quot;abc123xyz&quot;&gt;</span></span>
<span class="line"><span style="color:#e1e4e8;">&lt;/head&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">&lt;head&gt;</span></span>
<span class="line"><span style="color:#24292e;">  &lt;meta name=&quot;csrf-token&quot; content=&quot;abc123xyz&quot;&gt;</span></span>
<span class="line"><span style="color:#24292e;">&lt;/head&gt;</span></span></code></pre></div><h3 id="samesite-cookie" tabindex="-1">SameSite Cookie <a class="header-anchor" href="#samesite-cookie" aria-label="Permalink to &quot;SameSite Cookie&quot;">​</a></h3><p>通过浏览器原生机制，阻止跨站请求时携带 Cookie。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">Set-Cookie: session=abc123; SameSite=Strict; HttpOnly; Secure</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Set-Cookie: session=abc123; SameSite=Strict; HttpOnly; Secure</span></span></code></pre></div><table><thead><tr><th>SameSite 值</th><th>作用</th></tr></thead><tbody><tr><td><code>Strict</code></td><td>完全不允许跨站请求带上 Cookie（推荐）✅</td></tr><tr><td><code>Lax</code></td><td>限制性允许 GET 请求带 Cookie（适中）⚠️</td></tr><tr><td><code>None</code></td><td>不限制，但必须 <code>Secure</code> 才行（最弱）⚠️</td></tr></tbody></table><h3 id="限制-content-type" tabindex="-1">限制 <code>Content-Type</code> <a class="header-anchor" href="#限制-content-type" aria-label="Permalink to &quot;限制 \`Content-Type\`&quot;">​</a></h3><p>浏览器在跨站请求中只能伪造非常<strong>有限的 Content-Type（称为“简单请求”）</strong></p><h4 id="浏览器允许的-简单请求" tabindex="-1">浏览器允许的“简单请求”： <a class="header-anchor" href="#浏览器允许的-简单请求" aria-label="Permalink to &quot;浏览器允许的“简单请求”：&quot;">​</a></h4><ul><li><code>Content-Type: application/x-www-form-urlencoded</code></li><li><code>Content-Type: multipart/form-data</code></li><li><code>Content-Type: text/plain</code></li></ul><p>黑客构造 POST 表单就是用的 <code>application/x-www-form-urlencoded</code></p><p>所以服务器可以只接受 JSON 请求（非简单请求）：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">Content-Type: application/json</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Content-Type: application/json</span></span></code></pre></div><h3 id="检查-referer-origin-请求头" tabindex="-1">检查 Referer / Origin 请求头 <a class="header-anchor" href="#检查-referer-origin-请求头" aria-label="Permalink to &quot;检查 Referer / Origin 请求头&quot;">​</a></h3><ul><li>在请求头中，浏览器会带上 Referer 或 Origin，表明请求来源</li><li>后端检查是否来自本站</li></ul><p>这种方式<strong>可以做辅助判断</strong></p>`,34),l=[o];function p(c,i,r,d,u,h){return t(),a("div",null,l)}const g=e(n,[["render",p]]);export{y as __pageData,g as default};
