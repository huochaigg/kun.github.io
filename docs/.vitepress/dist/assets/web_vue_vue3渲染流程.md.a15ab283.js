import{_ as e,c as a,o as s,Q as n}from"./chunks/framework.ef145a76.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"web/vue/vue3渲染流程.md","filePath":"web/vue/vue3渲染流程.md"}'),l={name:"web/vue/vue3渲染流程.md"},o=n(`<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark has-diff vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">模板 Template (SFC/HTML)</span></span>
<span class="line"><span style="color:#e1e4e8;">       ↓ 编译器编译</span></span>
<span class="line"><span style="color:#e1e4e8;">AST（抽象语法树）</span></span>
<span class="line"><span style="color:#e1e4e8;">       ↓ 转换</span></span>
<span class="line"><span style="color:#e1e4e8;">Render Function（JS函数）</span></span>
<span class="line"><span style="color:#e1e4e8;">       ↓ 执行</span></span>
<span class="line"><span style="color:#e1e4e8;">VNode（虚拟 DOM）</span></span>
<span class="line"><span style="color:#e1e4e8;">       ↓ patch（diff 比较）</span></span>
<span class="line"><span style="color:#e1e4e8;">真实 DOM</span></span></code></pre><pre class="shiki github-light has-diff vp-code-light"><code><span class="line"><span style="color:#24292e;">模板 Template (SFC/HTML)</span></span>
<span class="line"><span style="color:#24292e;">       ↓ 编译器编译</span></span>
<span class="line"><span style="color:#24292e;">AST（抽象语法树）</span></span>
<span class="line"><span style="color:#24292e;">       ↓ 转换</span></span>
<span class="line"><span style="color:#24292e;">Render Function（JS函数）</span></span>
<span class="line"><span style="color:#24292e;">       ↓ 执行</span></span>
<span class="line"><span style="color:#24292e;">VNode（虚拟 DOM）</span></span>
<span class="line"><span style="color:#24292e;">       ↓ patch（diff 比较）</span></span>
<span class="line"><span style="color:#24292e;">真实 DOM</span></span></code></pre></div><h2 id="我的疑问" tabindex="-1">我的疑问： <a class="header-anchor" href="#我的疑问" aria-label="Permalink to &quot;我的疑问：&quot;">​</a></h2><h3 id="vnode-→-patch-对比阶段-每次更新都会额外存一份vnode吗-以供下次对比" tabindex="-1">.VNode → patch（对比阶段），每次更新都会额外存一份VNode吗？以供下次对比？ <a class="header-anchor" href="#vnode-→-patch-对比阶段-每次更新都会额外存一份vnode吗-以供下次对比" aria-label="Permalink to &quot;.VNode → patch（对比阶段），每次更新都会额外存一份VNode吗？以供下次对比？&quot;">​</a></h3><p>是的，Vue 在内存中保留“上一轮的 VNode 树”作为旧节点进行 diff 比较，并且 旧 VNode 在 diff 完之后会被 GC 回收，每个组件实例只维护一棵自己的 subTree（VNode 树）</p><h3 id="那么template为什么不直接转为虚拟-dom-树呢-而是先转为ast再转为渲染函数再转为vnode树" tabindex="-1">那么template为什么不直接转为虚拟 DOM 树呢？而是先转为AST再转为渲染函数再转为VNode树？ <a class="header-anchor" href="#那么template为什么不直接转为虚拟-dom-树呢-而是先转为ast再转为渲染函数再转为vnode树" aria-label="Permalink to &quot;那么template为什么不直接转为虚拟 DOM 树呢？而是先转为AST再转为渲染函数再转为VNode树？&quot;">​</a></h3><h4 id="deepseek" tabindex="-1">DeepSeek: <a class="header-anchor" href="#deepseek" aria-label="Permalink to &quot;DeepSeek:&quot;">​</a></h4><h4 id="设计方面" tabindex="-1">设计方面： <a class="header-anchor" href="#设计方面" aria-label="Permalink to &quot;设计方面：&quot;">​</a></h4><p>这种分层设计体现了Vue的架构理念：</p><ul><li><strong>关注点分离</strong>：编译时和运行时逻辑分离</li><li><strong>可扩展性</strong>：便于添加自定义编译器或自定义渲染器</li><li><strong>渐进式</strong>：支持template和JSX等多种写法</li></ul><h4 id="ast-抽象语法树-的必要性" tabindex="-1">AST（抽象语法树）的必要性： <a class="header-anchor" href="#ast-抽象语法树-的必要性" aria-label="Permalink to &quot;AST（抽象语法树）的必要性：&quot;">​</a></h4><p><strong>AST作为中间表示层</strong>提供了关键优势：</p><ul><li><strong>结构化分析</strong>：AST是对模板的完整结构化表示，便于进行静态分析和优化</li><li><strong>跨平台兼容</strong>：AST是平台无关的，可以基于它生成不同平台的渲染代码</li><li><strong>转换灵活性</strong>：在AST阶段可以进行各种转换和优化（如静态节点提升）</li></ul><h4 id="_2-渲染函数的作用" tabindex="-1">2. 渲染函数的作用 <a class="header-anchor" href="#_2-渲染函数的作用" aria-label="Permalink to &quot;2. 渲染函数的作用&quot;">​</a></h4><p>将AST转换为渲染函数而不是直接生成VNode，主要因为：</p><ul><li><strong>动态性</strong>：渲染函数可以在每次组件更新时被调用，根据最新状态生成VNode</li><li><strong>优化空间</strong>：Vue可以在编译时对渲染函数进行优化（如静态节点提升）</li><li><strong>灵活性</strong>：开发者也可以直接编写渲染函数，绕过template编译过程</li></ul><h4 id="_3-性能考量" tabindex="-1">3. 性能考量 <a class="header-anchor" href="#_3-性能考量" aria-label="Permalink to &quot;3. 性能考量&quot;">​</a></h4><p>虽然看起来多了一步转换，但实际上：</p><ul><li><strong>编译时优化</strong>：AST到渲染函数的转换是在构建时完成的（使用vue-loader等工具）</li><li><strong>运行时效率</strong>：预编译的渲染函数比直接解析template到VNode更高效</li></ul><p>Vue渲染相关： <a href="https://zhuanlan.zhihu.com/p/609128099" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/609128099</a></p>`,19),t=[o];function p(r,i,c,d,h,u){return s(),a("div",null,t)}const m=e(l,[["render",p]]);export{g as __pageData,m as default};
