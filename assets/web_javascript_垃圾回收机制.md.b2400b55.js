import{_ as a,c as e,o as s,Q as t}from"./chunks/framework.ef145a76.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"web/javascript/垃圾回收机制.md","filePath":"web/javascript/垃圾回收机制.md"}'),l={name:"web/javascript/垃圾回收机制.md"},n=t(`<h2 id="基础原则-可达性" tabindex="-1">基础原则：<strong>可达性</strong> <a class="header-anchor" href="#基础原则-可达性" aria-label="Permalink to &quot;基础原则：**可达性**&quot;">​</a></h2><p>即只要一个值是可达的，它就不会被回收</p><h2 id="v8-垃圾回收的分代机制" tabindex="-1">V8 垃圾回收的分代机制 <a class="header-anchor" href="#v8-垃圾回收的分代机制" aria-label="Permalink to &quot;V8 垃圾回收的分代机制&quot;">​</a></h2><h3 id="新生代" tabindex="-1">新生代 <a class="header-anchor" href="#新生代" aria-label="Permalink to &quot;新生代&quot;">​</a></h3><ul><li><p>存储<strong>生命周期短</strong>的对象</p></li><li><p>使用 Scavenge 算法：将内存划分成两个空间（from/to），对象在空间之间复制、清除不活跃对象</p></li><li><p>快速回收</p></li></ul><h3 id="老生代" tabindex="-1">老生代 <a class="header-anchor" href="#老生代" aria-label="Permalink to &quot;老生代&quot;">​</a></h3><ul><li><p>进入条件：对象存活次数较多，或内存较大</p></li><li><p>使用标记-清除 + 标记-压缩</p></li><li><p>回收代价高、速度慢</p></li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">新生代：适合频繁创建/销毁的小对象，回收快</span></span>
<span class="line"><span style="color:#e1e4e8;">老生代：适合持久性长的对象，慎用</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">新生代：适合频繁创建/销毁的小对象，回收快</span></span>
<span class="line"><span style="color:#24292e;">老生代：适合持久性长的对象，慎用</span></span></code></pre></div>`,8),o=[n];function i(r,p,c,d,h,_){return s(),e("div",null,o)}const m=a(l,[["render",i]]);export{b as __pageData,m as default};
