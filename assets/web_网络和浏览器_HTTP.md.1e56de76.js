import{_ as t,c as e,o as a,Q as o}from"./chunks/framework.ef145a76.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"web/网络和浏览器/HTTP.md","filePath":"web/网络和浏览器/HTTP.md"}'),s={name:"web/网络和浏览器/HTTP.md"},d=o(`<h2 id="http-和-https-区别" tabindex="-1">HTTP 和 HTTPS 区别 <a class="header-anchor" href="#http-和-https-区别" aria-label="Permalink to &quot;HTTP 和 HTTPS 区别&quot;">​</a></h2><table><thead><tr><th>对比项</th><th>HTTP</th><th>HTTPS</th></tr></thead><tbody><tr><td><strong>是否加密</strong></td><td>❌ 明文传输，容易被窃听</td><td>✅ 使用 SSL/TLS 加密，安全性高</td></tr><tr><td><strong>端口号</strong></td><td>默认端口 80</td><td>默认端口 443</td></tr><tr><td><strong>URL 格式</strong></td><td><code>http://</code> 开头</td><td><code>https://</code> 开头</td></tr><tr><td><strong>安全性</strong></td><td>无加密，容易被中间人攻击（抓包、篡改）</td><td>加密+认证+完整性校验</td></tr><tr><td><strong>性能</strong></td><td>快（无加密开销）</td><td>慢一点（但现代优化已趋近）</td></tr><tr><td><strong>证书</strong></td><td>不需要</td><td>需要服务器配置 SSL 证书</td></tr><tr><td><strong>SEO 影响</strong></td><td>差，搜索引擎会提示不安全</td><td>更有利于排名和信任</td></tr></tbody></table><h2 id="浏览器请求生命周期" tabindex="-1">浏览器请求生命周期 <a class="header-anchor" href="#浏览器请求生命周期" aria-label="Permalink to &quot;浏览器请求生命周期&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">1. 浏览器启动</span></span>
<span class="line"><span style="color:#e1e4e8;">2. 输入 URL，开始加载页面</span></span>
<span class="line"><span style="color:#e1e4e8;">3. DNS 解析、TCP/TLS 连接建立</span></span>
<span class="line"><span style="color:#e1e4e8;">4. 发送 HTTP 请求，获取响应</span></span>
<span class="line"><span style="color:#e1e4e8;">5. HTML 解析，构建 DOM 树</span></span>
<span class="line"><span style="color:#e1e4e8;">6. 加载 CSS、JS、图片等资源，构建 CSSOM</span></span>
<span class="line"><span style="color:#e1e4e8;">7. 构建 Render Tree，开始渲染</span></span>
<span class="line"><span style="color:#e1e4e8;">8. 页面首次绘制 (First Paint)</span></span>
<span class="line"><span style="color:#e1e4e8;">9. 页面可交互 (DOMContentLoaded、load)</span></span>
<span class="line"><span style="color:#e1e4e8;">10. 用户交互</span></span>
<span class="line"><span style="color:#e1e4e8;">11. 页面卸载（关闭、跳转、刷新）</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">1. 浏览器启动</span></span>
<span class="line"><span style="color:#24292e;">2. 输入 URL，开始加载页面</span></span>
<span class="line"><span style="color:#24292e;">3. DNS 解析、TCP/TLS 连接建立</span></span>
<span class="line"><span style="color:#24292e;">4. 发送 HTTP 请求，获取响应</span></span>
<span class="line"><span style="color:#24292e;">5. HTML 解析，构建 DOM 树</span></span>
<span class="line"><span style="color:#24292e;">6. 加载 CSS、JS、图片等资源，构建 CSSOM</span></span>
<span class="line"><span style="color:#24292e;">7. 构建 Render Tree，开始渲染</span></span>
<span class="line"><span style="color:#24292e;">8. 页面首次绘制 (First Paint)</span></span>
<span class="line"><span style="color:#24292e;">9. 页面可交互 (DOMContentLoaded、load)</span></span>
<span class="line"><span style="color:#24292e;">10. 用户交互</span></span>
<span class="line"><span style="color:#24292e;">11. 页面卸载（关闭、跳转、刷新）</span></span></code></pre></div><h2 id="什么是-cors-如何实现" tabindex="-1">什么是 CORS？如何实现？ <a class="header-anchor" href="#什么是-cors-如何实现" aria-label="Permalink to &quot;什么是 CORS？如何实现？&quot;">​</a></h2><p><strong>CORS（跨域资源共享，Cross-Origin Resource Sharing）</strong> 是一种浏览器的安全策略，它允许浏览器向<strong>不同源的服务器发起请求</strong>时，服务器通过设置响应头来授权访问。</p><p>跨域：浏览器认为其中任一不同就算跨域（<strong>协议、域名、端口</strong>），</p><p>CORS 是一种机制，它允许服务端告诉浏览器：</p><p>“我这个资源可以被某个特定的外域访问” 靠设置<strong>响应头</strong>来实现。</p><p>服务端设置</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">Access-Control-Allow-Origin: https://abc.com</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">Access-Control-Allow-Origin: * // 不建议</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Access-Control-Allow-Origin: https://abc.com</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">Access-Control-Allow-Origin: * // 不建议</span></span></code></pre></div><p>就允许来自 <code>https://abc.com</code> 的 JS 访问这个资源。</p><p>完整的 CORS 响应头（服务端）：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">Access-Control-Allow-Origin: https://example.com</span></span>
<span class="line"><span style="color:#e1e4e8;">Access-Control-Allow-Methods: GET, POST, PUT</span></span>
<span class="line"><span style="color:#e1e4e8;">Access-Control-Allow-Headers: Content-Type, Authorization</span></span>
<span class="line"><span style="color:#e1e4e8;">Access-Control-Allow-Credentials: true</span></span>
<span class="line"><span style="color:#e1e4e8;">Access-Control-Max-Age: 600</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Access-Control-Allow-Origin: https://example.com</span></span>
<span class="line"><span style="color:#24292e;">Access-Control-Allow-Methods: GET, POST, PUT</span></span>
<span class="line"><span style="color:#24292e;">Access-Control-Allow-Headers: Content-Type, Authorization</span></span>
<span class="line"><span style="color:#24292e;">Access-Control-Allow-Credentials: true</span></span>
<span class="line"><span style="color:#24292e;">Access-Control-Max-Age: 600</span></span></code></pre></div><h2 id="http-状态码-301、302、307、308-有什么区别" tabindex="-1">HTTP 状态码 301、302、307、308 有什么区别？ <a class="header-anchor" href="#http-状态码-301、302、307、308-有什么区别" aria-label="Permalink to &quot;HTTP 状态码 301、302、307、308 有什么区别？&quot;">​</a></h2><table><thead><tr><th>状态码</th><th>是否永久</th><th>请求方法改变？</th><th>特点说明</th></tr></thead><tbody><tr><td><strong>301</strong></td><td>✅ 永久</td><td>✅ 可能改变（POST → GET）</td><td>浏览器/搜索引擎会记住跳转（缓存）</td></tr><tr><td><strong>302</strong></td><td>❌ 临时</td><td>✅ 可能改变（POST → GET）</td><td>原始意义是临时，但多数浏览器也改变方法</td></tr><tr><td><strong>307</strong></td><td>❌ 临时</td><td>❌ 不改变（保持 POST）</td><td>明确要求<strong>方法不变</strong>，适用于需要安全重试的 POST</td></tr><tr><td><strong>308</strong></td><td>✅ 永久</td><td>❌ 不改变（保持 POST）</td><td>和 301 类似，但不允许改变方法</td></tr></tbody></table><h2 id="get-和-post-的区别" tabindex="-1">GET 和 POST 的区别？ <a class="header-anchor" href="#get-和-post-的区别" aria-label="Permalink to &quot;GET 和 POST 的区别？&quot;">​</a></h2><h3 id="基本语义" tabindex="-1">基本语义 <a class="header-anchor" href="#基本语义" aria-label="Permalink to &quot;基本语义&quot;">​</a></h3><table><thead><tr><th>方法</th><th>含义</th><th>用途示例</th></tr></thead><tbody><tr><td>GET</td><td><strong>获取资源</strong>（查）</td><td>查询文章、获取用户信息等</td></tr><tr><td>POST</td><td><strong>提交资源/处理请求</strong>（增）</td><td>提交表单、新建用户、上传数据</td></tr></tbody></table><h3 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h3><table><thead><tr><th>对比项</th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td><strong>请求参数位置</strong></td><td>放在 URL 中：<code>/api/user?id=123</code></td><td>放在请求体中（body）：<code>{id:123}</code></td></tr><tr><td><strong>可见性</strong></td><td>参数明文显示在地址栏，<strong>不安全</strong></td><td>参数藏在请求体中，相对更安全</td></tr><tr><td><strong>浏览器缓存</strong></td><td>会被浏览器缓存</td><td>不会被缓存</td></tr><tr><td><strong>书签收藏</strong></td><td>可以直接收藏</td><td>不可以</td></tr><tr><td><strong>幂等性</strong>（重要）</td><td>是，刷新多次不会造成影响</td><td>否，刷新可能会导致数据重复创建等问题</td></tr><tr><td><strong>长度限制</strong></td><td>URL 长度有限（一般 ≤ 2KB）</td><td>无明显限制，可上传大量数据（如文件）</td></tr><tr><td><strong>默认 <code>Content-Type</code></strong></td><td><code>text/plain</code> 或无</td><td><code>application/x-www-form-urlencoded</code></td></tr><tr><td><strong>语义强调</strong></td><td>获取资源，不应修改服务端数据</td><td>提交数据，可能引起服务端状态变化</td></tr></tbody></table><h2 id="什么是强缓存和协商缓存-怎么判断命中" tabindex="-1">什么是强缓存和协商缓存？怎么判断命中？ <a class="header-anchor" href="#什么是强缓存和协商缓存-怎么判断命中" aria-label="Permalink to &quot;什么是强缓存和协商缓存？怎么判断命中？&quot;">​</a></h2><table><thead><tr><th>缓存方式</th><th>控制字段（响应头）</th><th>特点</th></tr></thead><tbody><tr><td>强缓存（强制使用缓存）</td><td><code>Cache-Control</code>, <code>Expires</code></td><td><strong>不会向服务器发送请求，直接使用本地缓存</strong></td></tr><tr><td>协商缓存（条件请求）</td><td><code>ETag</code> / <code>Last-Modified</code> + 请求头</td><td>向服务器发请求，服务器决定是否返回新内容或 304</td></tr><tr><td>…… 待补充</td><td></td><td></td></tr></tbody></table><h2 id="什么是幂等性-哪些方法是幂等的" tabindex="-1">什么是幂等性？哪些方法是幂等的？ <a class="header-anchor" href="#什么是幂等性-哪些方法是幂等的" aria-label="Permalink to &quot;什么是幂等性？哪些方法是幂等的？&quot;">​</a></h2><p>多次执行对服务端的结果没有副作用，一般使用GET请求获取数据，多次请求对服务端，数据库，日志等没有什么影响，所以是幂等的。而POST请求会提交表单，改变服务端状态，更新数据库内容，所以是不幂等的。</p><h2 id="http2-的多路复用是如何实现的" tabindex="-1">HTTP2 的多路复用是如何实现的？ <a class="header-anchor" href="#http2-的多路复用是如何实现的" aria-label="Permalink to &quot;HTTP2 的多路复用是如何实现的？&quot;">​</a></h2><p>多路复用：所有请求和响应都通过一个 TCP 连接进行复用，彼此不阻塞......待补充</p><h2 id="什么情况下返回-204-状态码-它和-200-有什么区别" tabindex="-1">什么情况下返回 204 状态码？它和 200 有什么区别？ <a class="header-anchor" href="#什么情况下返回-204-状态码-它和-200-有什么区别" aria-label="Permalink to &quot;什么情况下返回 204 状态码？它和 200 有什么区别？&quot;">​</a></h2><ul><li>状态码：204</li><li>无返回体（<code>response body</code> 为空）</li><li>有响应头，但没有内容</li><li>通常用于「只需告知成功、但无需数据返回」的场景</li></ul><table><thead><tr><th>状态码</th><th>含义</th><th>有返回体？</th><th>常见用途</th></tr></thead><tbody><tr><td><code>200 OK</code></td><td>请求成功</td><td>有（可以是 JSON、HTML、文本等）</td><td>普通成功响应，带有内容</td></tr><tr><td><code>204 No Content</code></td><td>请求成功，但无内容返回</td><td>无</td><td>表单提交成功但无反馈、按钮点击后无需刷新、AJAX 无刷新交互等</td></tr></tbody></table><p>204比200更轻量的”成功“响应</p><h2 id="https-握手过程" tabindex="-1">HTTPS 握手过程 <a class="header-anchor" href="#https-握手过程" aria-label="Permalink to &quot;HTTPS 握手过程&quot;">​</a></h2><h3 id="整体流程" tabindex="-1">整体流程： <a class="header-anchor" href="#整体流程" aria-label="Permalink to &quot;整体流程：&quot;">​</a></h3><p>浏览器访问 HTTPS 网站时：</p><ol><li><p>客户端发起连接请求</p></li><li><p>服务端返回证书（含公钥）</p></li><li><p>客户端验证证书是否合法</p></li><li><p>客户端生成「对称密钥」并用服务端公钥加密后发出</p></li><li><p>服务端用私钥解密拿到「对称密钥」</p></li><li><p><strong>双方使用对称密钥开始加密通信</strong></p></li></ol><h3 id="tcp三次握手" tabindex="-1">TCP三次握手 <a class="header-anchor" href="#tcp三次握手" aria-label="Permalink to &quot;TCP三次握手&quot;">​</a></h3><ul><li><p><strong>第一次握手</strong>：客户端发送一个带 SYN 标志的包，表示 “我要连接你”；</p></li><li><p><strong>第二次握手</strong>：服务器收到后，回复一个 <strong>SYN + ACK</strong>，表示 “我收到了，同时我也准备好了”；</p></li><li><p><strong>第三次握手</strong>：客户端再回复一个 ACK，表示 “我知道你准备好了”；</p></li></ul><h3 id="四次挥手-断开连接" tabindex="-1">四次挥手（断开连接） <a class="header-anchor" href="#四次挥手-断开连接" aria-label="Permalink to &quot;四次挥手（断开连接）&quot;">​</a></h3><ul><li><p><strong>第一次挥手</strong>：客户端发送 FIN，请求断开连接（我要关闭发送）；</p></li><li><p><strong>第二次挥手</strong>：服务器返回 ACK（我知道了，但我还有数据要传）；</p></li><li><p><strong>第三次挥手</strong>：服务器准备好后，也发送一个 FIN（我现在也关闭了）；</p></li><li><p><strong>第四次挥手</strong>：客户端返回 ACK（确认断开）；</p></li><li><p>之后客户端会进入一个 <strong>TIME_WAIT</strong> 状态，等一会儿再彻底关闭，以确保服务器收到了最后的 ACK。</p></li></ul><h3 id="为什么不是两次握手-两次挥手" tabindex="-1">## 为什么不是两次握手/两次挥手？ <a class="header-anchor" href="#为什么不是两次握手-两次挥手" aria-label="Permalink to &quot;## 为什么不是两次握手/两次挥手？&quot;">​</a></h3><ul><li><p>握手需要确保双向通信都准备好，所以要三次。</p></li><li><p>挥手中，一方可能还有剩余数据未发送完，所以需要等它主动 FIN，因此是四次。</p></li></ul><table><thead><tr><th>标志位</th><th>含义</th><th>用于哪种场景</th></tr></thead><tbody><tr><td><strong>SYN</strong></td><td>Synchronize</td><td>建立连接（握手）</td></tr><tr><td><strong>ACK</strong></td><td>Acknowledgment</td><td>确认收到（应答）</td></tr><tr><td><strong>FIN</strong></td><td>Finish</td><td>断开连接（挥手）</td></tr></tbody></table><h3 id="tcp连接建立以后-下次请求是不是复用" tabindex="-1">TCP连接建立以后，下次请求是不是复用？ <a class="header-anchor" href="#tcp连接建立以后-下次请求是不是复用" aria-label="Permalink to &quot;TCP连接建立以后，下次请求是不是复用？&quot;">​</a></h3><p>默认情况下，<strong>每次 HTTP 请求都会重新建立 TCP 连接（开销大）</strong>。</p><p>但现代浏览器里有两个优化方式可以 <strong>复用连接</strong>：</p><h4 id="_1-http-1-1-的-connection-keep-alive" tabindex="-1">1. HTTP/1.1 的 <code>Connection: keep-alive</code> <a class="header-anchor" href="#_1-http-1-1-的-connection-keep-alive" aria-label="Permalink to &quot;1. HTTP/1.1 的 \`Connection: keep-alive\`&quot;">​</a></h4><ul><li><p>保持 TCP 连接不关闭，多个请求复用同一连接；</p></li><li><p>默认开启（除非明确设置 <code>Connection: close</code>）；</p></li><li><p>有个<strong>空闲超时</strong>（通常几十秒）后会自动断开。</p></li></ul><h4 id="_2-http-2-3-支持多路复用" tabindex="-1">2. HTTP/2/3 支持<strong>多路复用</strong> <a class="header-anchor" href="#_2-http-2-3-支持多路复用" aria-label="Permalink to &quot;2. HTTP/2/3 支持**多路复用**&quot;">​</a></h4><ul><li><p>一条连接中可以并发多个请求，不必等待前一个完成；</p></li><li><p>更快更省资源，是现代主流。</p></li></ul><h2 id="ssl-tls握手" tabindex="-1">SSL/TLS握手 <a class="header-anchor" href="#ssl-tls握手" aria-label="Permalink to &quot;SSL/TLS握手&quot;">​</a></h2><ul><li><p><strong>SSL（Secure Sockets Layer）</strong> 和 <strong>TLS（Transport Layer Security）</strong> 是一种加密协议；</p></li><li><p>目的是让 <strong>客户端（浏览器）和服务器</strong> 之间的通信是安全的；</p></li><li><p>TLS 是 SSL 的升级版（现代使用的其实是 TLS）。</p></li></ul><p>HTTPS 在开始正式通信前，会走一个 <strong>TLS 握手流程</strong>，大致步骤如下：</p><ol><li><h3 id="客户端发起请求" tabindex="-1">客户端发起请求 <a class="header-anchor" href="#客户端发起请求" aria-label="Permalink to &quot;客户端发起请求&quot;">​</a></h3><ul><li>浏览器发出请求：告诉服务器「我支持哪些加密方式」。</li></ul></li><li><h3 id="服务器响应" tabindex="-1">服务器响应 <a class="header-anchor" href="#服务器响应" aria-label="Permalink to &quot;服务器响应&quot;">​</a></h3><ul><li>服务器返回：<strong>SSL 证书</strong>、选择的加密方式等。</li></ul></li><li><h3 id="客户端验证证书" tabindex="-1">客户端验证证书 <a class="header-anchor" href="#客户端验证证书" aria-label="Permalink to &quot;客户端验证证书&quot;">​</a></h3><ul><li>验证证书是否可信（是否是受信 CA 签发、是否过期等）。</li><li>如果信任，则生成一个随机的对称密钥（<strong>用于后续加密通信</strong>）。</li></ul></li><li><h3 id="客户端使用公钥加密密钥" tabindex="-1">客户端使用公钥加密密钥 <a class="header-anchor" href="#客户端使用公钥加密密钥" aria-label="Permalink to &quot;客户端使用公钥加密密钥&quot;">​</a></h3><ul><li>把这个对称密钥，用服务器的 <strong>公钥加密</strong> 传过去。</li></ul></li><li><h3 id="服务器使用私钥解密" tabindex="-1">服务器使用私钥解密 <a class="header-anchor" href="#服务器使用私钥解密" aria-label="Permalink to &quot;服务器使用私钥解密&quot;">​</a></h3><ul><li>拿到密钥后，客户端和服务器用它进行 <strong>对称加密通信</strong>。</li></ul></li></ol><h2 id="证书的作用" tabindex="-1">证书的作用 <a class="header-anchor" href="#证书的作用" aria-label="Permalink to &quot;证书的作用&quot;">​</a></h2><p>SSL 证书是服务器用来「证明自己身份 + 提供公钥」的数字文档，作用如下：</p><table><thead><tr><th>作用</th><th>描述</th></tr></thead><tbody><tr><td><strong>身份认证</strong></td><td>浏览器可通过证书判断服务器是否是真实可信（非冒牌网站）</td></tr><tr><td><strong>传输加密</strong></td><td>提供服务器公钥用于数据加密，保护传输安全</td></tr><tr><td><strong>防止中间人攻击</strong></td><td>验证服务器合法性，防止被劫持或篡改</td></tr><tr><td><strong>包含信息</strong></td><td>域名、颁发机构（CA）、公钥、有效期、签名等</td></tr></tbody></table><h2 id="http1-2-3有哪些区别" tabindex="-1">HTTP1/2/3有哪些区别 <a class="header-anchor" href="#http1-2-3有哪些区别" aria-label="Permalink to &quot;HTTP1/2/3有哪些区别&quot;">​</a></h2><p>HTTP/2 多路复用，头部压缩</p><p>HTTP/3 弃用 TCP，改用 UDP + QUIC，结合了 TCP 的可靠性 + UDP 的高性能，解决了 HTTP/2 的核心瓶颈。</p><h2 id="http请求方法和语义" tabindex="-1">HTTP请求方法和语义 <a class="header-anchor" href="#http请求方法和语义" aria-label="Permalink to &quot;HTTP请求方法和语义&quot;">​</a></h2><table><thead><tr><th>方法</th><th>语义（用途）</th><th>是否幂等</th><th>是否常用于 REST</th></tr></thead><tbody><tr><td><code>GET</code></td><td><strong>获取资源</strong>，只读取，不修改资源</td><td>✅ 是</td><td>✅ 是</td></tr><tr><td><code>POST</code></td><td><strong>提交数据</strong>（创建资源、触发操作）</td><td>❌ 否</td><td>✅ 是</td></tr><tr><td><code>PUT</code></td><td><strong>更新整个资源</strong>（用新数据替换旧数据）</td><td>✅ 是</td><td>✅ 是</td></tr><tr><td><code>PATCH</code></td><td><strong>局部更新资源</strong>（只改部分字段）</td><td>❌ 否</td><td>✅ 是</td></tr><tr><td><code>DELETE</code></td><td><strong>删除资源</strong></td><td>✅ 是</td><td>✅ 是</td></tr><tr><td><code>HEAD</code></td><td>获取资源<strong>响应头</strong>，不返回 body</td><td>✅ 是</td><td>❌ 较少用</td></tr><tr><td><code>OPTIONS</code></td><td><strong>探测服务器支持哪些方法/跨域权限检查</strong></td><td>✅ 是</td><td>⚠️ 特殊用途</td></tr></tbody></table><h3 id="options-方法详解" tabindex="-1"><code>OPTIONS</code> 方法详解 <a class="header-anchor" href="#options-方法详解" aria-label="Permalink to &quot;\`OPTIONS\` 方法详解&quot;">​</a></h3><ul><li><p><code>OPTIONS</code> 方法用于：<strong>探测目标资源支持哪些请求方法和功能</strong>；</p></li><li><p>它不会返回实际的数据，只会返回响应头中的「允许行为」；</p></li><li><p>它也是 <strong>CORS 跨域机制中的预检请求（preflight request）</strong>；</p></li></ul><h4 id="为什么用-get-请求却看到浏览器发了-options-请求" tabindex="-1">为什么用 <code>GET</code> 请求却看到浏览器发了 <code>OPTIONS</code> 请求？ <a class="header-anchor" href="#为什么用-get-请求却看到浏览器发了-options-请求" aria-label="Permalink to &quot;为什么用 \`GET\` 请求却看到浏览器发了 \`OPTIONS\` 请求？&quot;">​</a></h4><p>这是因为你的请求<strong>触发了 CORS 的“预检请求”机制</strong>（preflight）。虽然是 <code>GET</code>，但只要<strong>满足“非简单请求”的条件</strong>，浏览器就会自动先发送一个 <code>OPTIONS</code> 请求来问后端：“我能发这个请求吗？“</p><table><thead><tr><th>条件</th><th>是否触发 OPTIONS</th></tr></thead><tbody><tr><td><code>Content-Type</code> 是 <code>application/json</code></td><td>✅ 会触发</td></tr><tr><td>设置了 <code>withCredentials: true</code>（带 cookie）</td><td>✅ 会触发</td></tr><tr><td>自定义请求头（如 <code>Authorization</code>）</td><td>✅ 会触发</td></tr><tr><td>方法是 <code>PUT</code>, <code>PATCH</code>, <code>DELETE</code></td><td>✅ 会触发</td></tr><tr><td><code>GET</code> 或 <code>POST</code> 且不带上面这些情况</td><td>❌ 不触发（为“简单请求”）</td></tr></tbody></table><h4 id="什么是简单请求-非简单请求" tabindex="-1">什么是简单请求 / 非简单请求 <a class="header-anchor" href="#什么是简单请求-非简单请求" aria-label="Permalink to &quot;什么是简单请求 / 非简单请求&quot;">​</a></h4><h3 id="简单请求的条件-只满足这三点才是简单请求" tabindex="-1">简单请求的条件（<strong>只满足这三点才是简单请求</strong>）： <a class="header-anchor" href="#简单请求的条件-只满足这三点才是简单请求" aria-label="Permalink to &quot;简单请求的条件（**只满足这三点才是简单请求**）：&quot;">​</a></h3><ol><li>方法是以下三种之一： <ul><li><code>GET</code></li><li><code>POST</code></li><li><code>HEAD</code></li></ul></li><li>请求头必须只包含： <ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Content-Type</code>（且仅限这三种：<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>）</li></ul></li><li>不能使用 <code>withCredentials</code>，不能携带自定义头部（如 <code>Authorization</code>）。</li></ol><h3 id="非简单请求-也称-需预检请求" tabindex="-1">非简单请求（也称 “需预检请求”）： <a class="header-anchor" href="#非简单请求-也称-需预检请求" aria-label="Permalink to &quot;非简单请求（也称 “需预检请求”）：&quot;">​</a></h3><p>任何 <strong>不满足上面任一条件</strong> 的请求，浏览器都会：</p><ul><li><strong>自动先发一个 <code>OPTIONS</code> 请求</strong>（预检）；</li><li>服务端返回通过后，浏览器才会继续发送真正的请求。</li></ul>`,72),n=[d];function r(l,i,c,p,h,g){return a(),e("div",null,n)}const b=t(s,[["render",r]]);export{u as __pageData,b as default};
