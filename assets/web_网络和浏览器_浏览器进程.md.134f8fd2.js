import{_ as t,c as a,o as e,Q as r}from"./chunks/framework.ef145a76.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"web/网络和浏览器/浏览器进程.md","filePath":"web/网络和浏览器/浏览器进程.md"}'),o={name:"web/网络和浏览器/浏览器进程.md"},d=r('<h2 id="浏览器的进程模型" tabindex="-1">浏览器的进程模型 <a class="header-anchor" href="#浏览器的进程模型" aria-label="Permalink to &quot;浏览器的进程模型&quot;">​</a></h2><h3 id="何为进程" tabindex="-1">何为进程 <a class="header-anchor" href="#何为进程" aria-label="Permalink to &quot;何为进程&quot;">​</a></h3><p>程序需要有自己单独的内存空间，可以把这块内存空间简单理解为进程</p><p>每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意</p><p>一个进程至少有一个线程，所以在开启之后会自动创建一个线程来运行代码，该线程称之为主线程。</p><p>如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中包含多个线程</p><h3 id="chrome-浏览器中有多少个进程" tabindex="-1">Chrome 浏览器中有多少个进程？ <a class="header-anchor" href="#chrome-浏览器中有多少个进程" aria-label="Permalink to &quot;Chrome 浏览器中有多少个进程？&quot;">​</a></h3><p>Chrome 的进程数量<strong>动态变化</strong>，取决于以下因素：</p><ol><li><p>打开了多少个标签页；</p></li><li><p>每个标签页是否跨站点（iframe 是否跨 origin）；</p></li><li><p>是否启用了站点隔离（Site Isolation）；</p></li><li><p>安装了多少扩展插件；</p></li><li><p>是否有正在使用的 GPU、音视频功能等。</p></li></ol><h3 id="示例-打开-3-个不同网站的标签页" tabindex="-1">示例（打开 3 个不同网站的标签页）： <a class="header-anchor" href="#示例-打开-3-个不同网站的标签页" aria-label="Permalink to &quot;示例（打开 3 个不同网站的标签页）：&quot;">​</a></h3><table><thead><tr><th>类型</th><th>数量</th></tr></thead><tbody><tr><td>Browser 主进程</td><td>1</td></tr><tr><td>渲染进程（Renderer）</td><td>3</td></tr><tr><td>GPU 进程</td><td>1</td></tr><tr><td>网络服务进程</td><td>1</td></tr><tr><td>插件进程（如有扩展）</td><td>若干</td></tr></tbody></table><p><strong>通常 Chrome 会占用 5~20 个进程不等。</strong></p><h3 id="浏览器有哪些进程和线程" tabindex="-1">浏览器有哪些进程和线程? <a class="header-anchor" href="#浏览器有哪些进程和线程" aria-label="Permalink to &quot;浏览器有哪些进程和线程?&quot;">​</a></h3><p><strong>浏览器是一个多进程多线程的应用程序</strong> 浏览器内部工作极其复杂。 为了避免相互影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程。</p><p>其中，最主要的进程有:</p><p>1.浏览器进程 主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。</p><p>2.网络进程 负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。</p><p>3.渲染进程 渲染进程启动后，会开启一个渲染主线程，主线程负责执行HTML、CSS、JS代码。 默认情况下，浏览器会为每个标签页我启一个新的渲染进程，以保证不同的标签页之间不相互影响。</p><h3 id="渲染主线程是如何工作的" tabindex="-1">渲染主线程是如何工作的? <a class="header-anchor" href="#渲染主线程是如何工作的" aria-label="Permalink to &quot;渲染主线程是如何工作的?&quot;">​</a></h3><p>渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于:</p><p>解析 HTML 解析 CSS 计算样式 布局 处理图层 每秒把页面画 60次 执行全局js代码 执行事件处理函数 执行计时器的回调函数</p><p>在最开始的时候，渲染主线程会进入一个无限循环</p><p>每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循2.环;如果没有，则进入休眠状态。</p><p>其他所有线程(包括其他进程的线程)可以随时向消息队列添加任务。新任务会加到消息队列的未尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务</p><p>这样一来，就可以让每个任务有条不紊的、持续的进行下去了。整个过程，被称之为事件循环(消息循环)</p>',25),p=[d];function i(h,l,n,s,c,_){return e(),a("div",null,p)}const u=t(o,[["render",i]]);export{b as __pageData,u as default};
